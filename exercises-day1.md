The goal of Day 1 exercises is to assemble one chromosome of yeast genome, CBS1483, and then evaluate and visualize the assembly.

First we need to get started with the practical environment: download the zipped file titled `data-day1.tar.gz`, this contains the data and the `conda` environment that we will use in exercises today. We need to extract them.

##### Task: Get started

- Extract the contents of `data-day1.tar.gz`. You should have 2 folders and a new tarball titled `reads`, `reference`, and `vlpb1-conda.tar.gz`
- Create a directory titled `vlpb1` and extract the contents of `vlp1-conda.tar.gz` into this directory. We will be using this conda environment today.

```bash
mkdir vlpb1
tar -xzf vlpb1-conda.tar.gz -C vlpb1
cd vlpb1
conda activate
conda-unpack
```

##### Task: Explore the project directory

- In the beginning, your project directory should have the directory titled `reads` where the input reads for the assembly are stored. In this directory you will find the paired end short reads (`shortreads_p1.fastq` and `shortreads_p2.fastq`) and the long reads (`longreads.fastq`). You should create new directories to store the assembly output. 

```bash
mkdir assembly
```

##### Task: Explore the reads and calculate read statistics

- Before we begin, make sure you have the `vlpb1` environment activated. Next to the blinking cursor, you should see `(vlpb1)`. If not, activate the `conda` environment

```bash
conda activate vlpb1
```

- We will use `NanoPlot` to calculate read statistics and visualize them, we will create an `html` report.

```bash
NanoPlot --fastq <input file> -o <output directory> --plots hex dot kde
```

You should replace `<input file>` with 3 `fastq` files stored in `reads`: `shortreads1.fastq`, `shortreads2.fastq` and `longreads.fastq`. And you can use the `reads` directory to store the outputs or create a new subdirectory to keep your folder clean.

##### Question: What is the length range of the reads in your dataset? What is the coverage of the genome if the expected length of the assembly is 200kbp?

*HINT: Use the `html` output generated by `NanoPlot`*

##### Task: Preprocess reads

- Filter the long reads to remove reads shorter than 10kbp. Use `filtlong`

```bash
filtlong --min_length 10000 longreads.fastq > longreads_filtered.fastq
```

##### Question: Why do we need to filter the long reads before assembly? Do we need to do any additional QC for the long reads?

##### Task: Assemble chromosome I using `miniasm`

- To assemble the CBS1483 genome, we will first use `miniasm`. As input, `miniasm` requires pairwise alignment of long reads. To obtain this alignment, we will use `minimap2`. To keep things in order, let's first create a subdirectory for the `miniasm` assembly under the `assembly` directory

```bash
mkdir assembly/miniasm
```

- Then we can align the long reads
  
```bash
minimap2 -x ava-ont -t 2 reads/longreads_filtered.fastq data/reads/longreads_filtered.fastq > assembly/miniasm/pairwise_longread_alignment.paf
```

- And run `miniasm`
  
```bash
miniasm -f reads/longreads_filtered.fastq assembly/miniasm/pairwise_longread_alignment.paf > assembly/miniasm/miniasm_assembly.gfa
```

- Let's visualize the assembly graph
  
```bash
Bandage image assembly/miniasm/miniasm_assembly.gfa assembly/miniasm/miniasm_assembly.jpg
```

- We will also extract the sequence from the assembly graph to a `fasta` file so we can use it later
  
```bash
awk '/^S/{print ">"$2"\n"$3}' assembly/miniasm/miniasm_assembly.gfa | fold > assembly/miniasm/miniasm_assembly.fasta
  ```

##### Task: Assemble CBS1453 genome using `Flye`

- First, let's create a folder to store our assembly output.
  
```bash
mkdir assembly/flye
```

- This time we will assemble CBS1453 using `Flye`
  
```bash
flye --nano-raw reads/longreads_filtered.fastq reads/longreads_filtered.fastq -t 2 -g 12M -i 3 --asm-coverage 40 --out-dir assembly/flye
```

##### Task: Polish assembly with short reads

- Final step in assembly is to polish with short reads. For polishing, we will use `Pilon`. First, we need to align the short reads against our assembled genomes and to do that we should index our assembly. We will use `bwa` for indexing and alignment.
  
```bash
bwa index assembly/miniasm/miniasm_assembly.fasta
bwa mem -t 2 assembly/miniasm/miniasm_assembly.fasta reads/shortreads1.fastq reads/shortreads2.fastq > assembly/miniasm/miniasm_shortreads_aln.sam
  ```

- Next, we will convert the `sam` alignment output to binary format `bam`, sort the alignment and index the sorted `bam` alignment so that we can use it as input to `Pilon`.

```bash
samtools view -bS -q 35 assembly/miniasm/miniasm_shortreads_aln.sam > assembly/miniasm/miniasm_shortreads_aln.bam
samtools sort --threads 2 assembly/miniasm/miniasm_shortreads_aln.bam -o assembly/miniasm/miniasm_shortreads_aln.sorted.bam
samtools index assembly/miniasm/miniasm_shortreads_aln.sorted.bam
```

- Now we can run `Pilon`
  
```bash
pilon --genome assembly/miniasm/miniasm_assembly.fasta --frags assembly/miniasm/miniasm_shortreads_aln.sorted.bam --fix all --output miniasm_assembly_polished --outdir assembly/miniasm --changes --vcf > assembly/miniasm/pilon.log
```

- You should repeat the same steps for the `Flye` assembly.

##### Question: Who do we need polishing? Why do we use short reads (instead of long reads) for polishing?

##### Question: Can you think of any downsides to polishing with short reads?

##### Task: Evaluate assembly

- To evaluate the final polished assemblies, we will use `Quast`. First, create a subdirectory to store the outputs. And run the program on both the initial and the polished assembly as follows:
  
```bash
mkdir assembly/miniasm/quast
# On the initial assembly (before polishing)
quast assembly/miniasm/miniasm_assembly.fasta -r reference/reference_scI_CP048983.1.fasta -g reference/reference_scI_CP048983.1.gff -o assembly/miniasm/quast --threads 2
# On the polished assembly
quast assembly/miniasm/miniasm_assembly_polished.fasta -r reference/reference_scI_CP048983.1.fasta -g reference/reference_scI_CP048983.1.gff -o assembly/miniasm/quast --threads 2
```

- Repeat the same steps for the `Flye` assembly

##### Question: Do you notice any difference between the polished and unpolished assembly
